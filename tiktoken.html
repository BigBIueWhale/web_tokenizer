<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tokenizer</title>
    <style>
        :root {
            --bg-color: #f3f4f6;
            --text-color: #1f2937;
            --border-color: #e5e7eb;
            --accent-color: #3b82f6;
            --accent-hover: #2563eb;
            --danger-color: #ef4444;
            --success-color: #10b981;
            --mono-font: 'Menlo', 'Consolas', 'Monaco', 'Liberation Mono', 'Lucida Console', monospace;
            --sans-font: 'Inter', system-ui, -apple-system, sans-serif;
            --card-bg: #ffffff;
            --disabled-color: #9ca3af;
            
            /* --- Strict Line Height for Sync --- */
            /* Essential for mapping scroll offsets between the raw textarea and the token visualizer */
            --strict-line-height: 24px;

            /* --- Line Number Gutter Width --- */
            --line-number-gutter-width: 56px;
        }

        * { box-sizing: border-box; }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            font-family: var(--sans-font);
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden; /* App handles scrolling internally */
        }

        /* --- LOAD SCREEN --- */
        #load-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.3s ease;
        }

        .load-card {
            background: white;
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        #drop-zone {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 40px 20px;
            background-color: #f8fafc;
            transition: all 0.2s ease;
            cursor: pointer;
            margin: 20px 0;
        }

        #drop-zone:hover, #drop-zone.drag-active {
            border-color: var(--accent-color);
            background-color: #eff6ff;
        }

        /* --- Initial load hint styling --- */
        .load-hint {
            margin-top: 12px;
            font-size: 0.8rem;
            color: #4b5563;
            text-align: left;
            background-color: #f9fafb;
            border-radius: 8px;
            padding: 10px 12px;
        }

        .load-hint code {
            background: #e5e7eb;
            padding: 1px 4px;
            border-radius: 4px;
            font-family: var(--mono-font);
            font-size: 0.8rem;
        }

        .load-hint a {
            color: var(--accent-color);
            text-decoration: none;
            word-break: break-all;
        }

        .load-hint a:hover {
            text-decoration: underline;
        }

        /* --- MAIN LAYOUT --- */
        #app-container {
            display: none;
            height: 100vh;
            width: 100vw;        /* Fill full available width */
            flex-direction: column;
            padding: 20px;
            /* REMOVED max-width & centering so the app uses the entire screen width */
            gap: 20px;
        }

        /* --- HEADER SECTION (Stats & Cards) --- */
        #header-grid {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
            flex-shrink: 0;
        }

        /* Total Tokens Card & Control Area */
        .stat-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Space between number and button */
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
            gap: 12px; 
        }

        .stat-content {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .stat-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #6b7280;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 2.2rem;
            font-weight: 700;
            color: #111827;
            line-height: 1;
        }

        /* Action Button */
        #btn-compute {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background-color: var(--accent-color);
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s, opacity 0.2s;
            text-align: center;
            /* RIGHT pane is now fully virtual; hide the old manual button to reclaim vertical space */
            display: none;
        }

        #btn-compute:hover:not(:disabled) {
            background-color: var(--accent-hover);
        }

        #btn-compute:disabled {
            background-color: var(--bg-color);
            color: var(--disabled-color);
            cursor: not-allowed;
            border: 1px solid var(--border-color);
        }

        /* Loading Spinner inside Stats */
        .spinner {
            width: 16px; height: 16px;
            border: 2px solid #e5e7eb;
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            position: absolute;
            top: 20px; right: 20px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .spinner.active { opacity: 1; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Providers Vertical Stack */
        .providers-stack {
            display: flex;
            flex-direction: row; /* Place first percent bar to the left of the second */
            flex-wrap: wrap;
            gap: 10px;
        }

        .provider-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
            flex: 1 1 0;
            min-width: 0;
        }

        .provider-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .provider-meta { display: flex; flex-direction: column; overflow: hidden; }
        .provider-url { font-size: 0.75rem; color: var(--accent-color); font-family: var(--mono-font); margin-bottom: 2px; text-decoration: none; }
        .provider-model { font-size: 0.9rem; font-weight: 600; color: #374151; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        .provider-stats { text-align: right; min-width: 80px; }
        .usage-percent { font-size: 1rem; font-weight: 700; color: #374151; }
        .usage-percent.over-limit { color: var(--danger-color); }
        .usage-max { font-size: 0.7rem; color: #9ca3af; }

        .progress-bar {
            height: 6px;
            background: #f3f4f6;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
        }
        .progress-fill {
            height: 100%;
            background: var(--accent-color);
            width: 0%;
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        .progress-fill.danger { background: var(--danger-color); }

        /* --- EDITOR SPLIT PANE --- */
        #editor-container {
            flex-grow: 1;
            display: grid;
            /* STRICT 50/50 split */
            grid-template-columns: 1fr 1fr; 
            gap: 0; /* Connected look */
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
            
            /* --- SCROLLABLE CHILDREN --- */
            overflow: hidden; /* Parent does NOT scroll */
            align-items: start; /* Ensure content starts at top */
        }

        .pane-header {
            background: #f9fafb;
            border-bottom: 1px solid var(--border-color);
            padding: 8px 16px;
            font-size: 0.75rem;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            
            /* Sticky Header */
            /* Note: Since parent overflow is hidden, sticky inside flex children works if configured right, 
               but here we are scrolling the .pane-content BELOW the header. 
               The header sits in .left-pane which is flex column. */
            z-index: 10;
        }

        .pane-content {
            padding: 20px;
            font-family: var(--mono-font);
            font-size: 14px;
            
            /* --- Strict Line Height & NO WRAP --- */
            line-height: var(--strict-line-height); /* 24px fixed */
            white-space: pre;       /* Disable Wrapping */
            overflow: auto;        /* Enable Both Scrolls on the PANE */
            
            /* --- Remove Wrapping Logic --- */
            overflow-wrap: normal;
            word-break: normal;
            
            width: 100%;
            /* Height 100% of the remaining space in the flex column (header takes some) */
            flex-grow: 1; 
            height: 0; /* Force flex child to respect container height for scrolling */
            will-change: scroll-position;
        }

        /* --- Normalize Text Rendering --- 
           Force the textarea and the div to calculate width and spacing identically 
        */
        #text-input, #token-visualizer, .t-token {
            line-height: var(--strict-line-height) !important;
            font-size: 16px; /* Ensure font fits within line-height */
            font-family: 'Consolas', 'Monaco', monospace;
        }

        /* Input specific */
        .left-pane {
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            min-width: 0; /* Critical for CSS Grid to respect 50% width with long content */
            height: 100%; /* Fill grid cell */
            overflow: hidden; /* Contain inner scroll */
        }

        /* Scroll container for input + line numbers */
        .left-scroll-container {
            position: relative;
            flex-grow: 1;
            height: 0;
            width: 100%;
            overflow: hidden;
        }

        #text-input {
            border: none;
            resize: none;
            outline: none;
            color: #1f2937;
            background-color: #ffffff;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            /* match pane padding, plus gutter on the left */
            padding-top: 20px;
            padding-right: 20px;
            padding-bottom: 20px;
            padding-left: calc(20px + var(--line-number-gutter-width));
            white-space: pre;
            overflow: auto;
            overflow-wrap: normal;
            word-break: normal;
        }
        #text-input::placeholder { color: #d1d5db; }

        /* Line number gutter */
        #line-number-gutter {
            position: absolute;
            top: 0;
            left: 0;
            width: var(--line-number-gutter-width);
            height: 100%;
            padding-top: 20px;
            padding-bottom: 20px;
            padding-left: 12px;
            padding-right: 4px;
            box-sizing: border-box;
            font-family: var(--mono-font);
            font-size: 12px;
            line-height: var(--strict-line-height);
            color: #9ca3af;
            background: linear-gradient(to right, #f9fafb, rgba(249, 250, 251, 0));
            text-align: right;
            pointer-events: none; /* clicks go through to textarea */
            overflow-y: scroll;
            overflow-x: hidden;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;      /* Firefox */
            z-index: 2;
        }

        #line-number-gutter::-webkit-scrollbar {
            width: 0;
            height: 0;
        }

        #line-numbers {
            /* all line numbers live here */
        }

        .line-number {
            height: var(--strict-line-height);
        }

        /* Virtual line-number spacers */
        #line-top-spacer,
        #line-bottom-spacer {
            width: 100%;
            height: 0;
            pointer-events: none;
        }

        /* Visualizer specific */
        .right-pane {
            display: flex;
            flex-direction: column;
            background-color: #fff;
            min-width: 0; /* Critical for CSS Grid to respect 50% width with long content */
            height: 100%; /* Fill grid cell */
            overflow: hidden; /* Contain inner scroll */
            
            /* --- Equalize Pixel Debt --- */
            border-left: 1px solid transparent; 
        }

        #token-visualizer {
            cursor: default;
            transition: opacity 0.2s ease;
        }
        #token-visualizer.stale {
            opacity: 0.4;
            filter: grayscale(100%);
        }

        /* Virtual token layout scaffolding for RIGHT pane */
        #token-top-spacer,
        #token-bottom-spacer {
            height: 0;
            pointer-events: none;
        }

        #token-visible-inner {
            display: inline;
        }

        /* Token Colors */
        .t-token {
            border-radius: 3px;
            padding: 1px 0;
            display: inline; /* Ensure it flows like text */
            box-decoration-break: clone;
            -webkit-box-decoration-break: clone;

            /* --- Kill Token Margins --- */
            margin: 0; 
            box-shadow: 0 0 0 1px #ffffff; /* Simulates a 1px white gap visually */
        }
        .c0 { background-color: #dbeafe; color: #1e40af; } /* Blue */
        .c1 { background-color: #dcfce7; color: #166534; } /* Green */
        .c2 { background-color: #f3e8ff; color: #6b21a8; } /* Purple */
        .c3 { background-color: #ffedd5; color: #9a3412; } /* Orange */
        .c4 { background-color: #fce7f3; color: #9d174d; } /* Pink */
        .c5 { background-color: #ccfbf1; color: #115e59; } /* Teal */

        /* Sync Status Dot */
        .sync-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background-color: #d1d5db;
        }
        .sync-dot.synced { background-color: var(--success-color); box-shadow: 0 0 4px var(--success-color); }
        .sync-dot.working { background-color: #fbbf24; animation: pulse 1s infinite; }

        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 5px; border: 2px solid #fff; }
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }

        /* Custom token tooltip (we don't rely on native title tooltips) */
        .token-tooltip {
            position: fixed;
            background: rgba(15, 23, 42, 0.96);
            color: #f9fafb;
            font-family: var(--mono-font);
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 2000;
            white-space: nowrap;
            box-shadow: 0 4px 6px rgba(0,0,0,0.15);
            transform: translate3d(0,0,0);
        }
        .token-tooltip.hidden {
            display: none;
        }

    </style>
</head>
<body>

    <div id="load-overlay">
        <div class="load-card">
            <h2 style="margin-top:0; color:#111827;">Tokenizer Setup</h2>
            <p style="color:#6b7280; margin-bottom: 20px;">Secure, Offline, High-Performance</p>
            
            <div id="drop-zone">
                <div style="font-size: 40px; margin-bottom: 10px;">ðŸ“„</div>
                <div style="font-weight: 500; color: #374151;">Drop 'o200k_base.json' here</div>
                <div style="font-size: 0.85rem; color: #9ca3af; margin-top: 5px;">or click to browse</div>
                <input type="file" id="json-upload" accept=".json" style="display:none;">
            </div>

            <div class="load-hint">
                Download <code>o200k_base.json</code> (filesize 2,325,547 bytes) from:<br>
                <a href="https://tiktoken.pages.dev/js/o200k_base.json" target="_blank" rel="noopener noreferrer">
                    https://tiktoken.pages.dev/js/o200k_base.json
                </a>
            </div>
            
            <p id="error-msg" style="color: var(--danger-color); font-size: 0.9rem; min-height: 20px;"></p>
            
            <div style="font-size: 0.75rem; color: #9ca3af; margin-top: 20px; border-top: 1px solid #eee; padding-top: 10px;">
                Required: <code style="background:#f3f4f6; padding: 2px 4px; border-radius: 4px;">o200k_base.json</code>
            </div>
        </div>
    </div>

    <div id="app-container">
        
        <div id="header-grid">
            <div class="stat-card">
                <div class="stat-content">
                    <span class="stat-label">Total Tokens</span>
                    <span class="stat-value" id="total-tokens">0</span>
                </div>
                <button id="btn-compute" disabled>Update View</button>
                <div class="spinner" id="main-spinner"></div>
            </div>

            <div class="providers-stack" id="providers-container">
            </div>
        </div>

        <div id="editor-container">
            <div class="left-pane">
                <div class="pane-header">
                    <span>Raw Input</span>
                </div>
                <div class="left-scroll-container">
                    <div id="line-number-gutter">
                        <div id="line-top-spacer"></div>
                        <div id="line-numbers"></div>
                        <div id="line-bottom-spacer"></div>
                    </div>
                    <textarea id="text-input" wrap="off" placeholder="Type or paste..." spellcheck="false" dir="auto"></textarea>
                </div>
            </div>

            <div class="right-pane">
                <div class="pane-header">
                    <span>Token View</span>
                    <div class="sync-dot" id="sync-status" title="Sync Status"></div>
                </div>
                <div id="token-visualizer" class="pane-content" dir="auto"></div>
            </div>
        </div>
    </div>

    <div id="token-tooltip" class="token-tooltip hidden"></div>

    <script id="worker-script" type="javascript/worker">
        // --- WORKER LOGIC ---
        const DOC_URL = "https://tiktoken.pages.dev/js/o200k_base.json";

        function assert(condition, message) {
            if (!condition) throw new Error(message);
        }

        // --- BPE Logic Helpers ---
        function bytePairMerge(piece, ranks) {
            let parts = Array.from({ length: piece.length }, (_, i) => ({ start: i, end: i + 1 }));
            while (parts.length > 1) {
                let minRank = null;
                let minIndex = -1;
                for (let i = 0; i < parts.length - 1; i++) {
                    const slice = piece.slice(parts[i].start, parts[i+1].end);
                    const key = slice.join(",");
                    const rank = ranks.get(key);
                    if (rank === undefined) continue;
                    if (minRank === null || rank < minRank) {
                        minRank = rank;
                        minIndex = i;
                    }
                }
                if (minRank !== null) {
                    const i = minIndex;
                    parts[i] = { start: parts[i].start, end: parts[i+1].end };
                    parts.splice(i + 1, 1);
                } else {
                    break;
                }
            }
            return parts;
        }

        // Returns Array of Uint8Arrays (the split segments)
        function bytePairSplit(piece, ranks) {
            if (piece.length === 1) return [piece];
            const merged = bytePairMerge(piece, ranks);
            
            // Map the merge parts back to the actual byte slices
            return merged.map(p => piece.slice(p.start, p.end));
        }

        class Tiktoken {
            constructor(jsonData) {
                assert(typeof jsonData === 'object' && jsonData !== null, "Invalid JSON: expected top-level object for encoding data");
                this.patStr = jsonData.pat_str;
                this.specialTokens = jsonData.special_tokens || {};
                this.rankMap = new Map();
                this.textEncoder = new TextEncoder();
                this.textDecoder = new TextDecoder("utf-8");
                // Compile the main regex once; we reuse it per encode call.
                this.pieceRegex = new RegExp(this.patStr, "ug");
                this.loadRanks(jsonData.bpe_ranks);
            }

            loadRanks(bpeRanksStr) {
                // For o200k_base.json, bpe_ranks is a single space-separated string:
                // "! <offset> <b64> <b64> ..."
                // We don't support any other format; anything else is a hard error with details.
                assert(typeof bpeRanksStr === "string", "Expected bpe_ranks to be a string");
                const parts = bpeRanksStr.split(" ").filter(Boolean);
                assert(
                    parts.length >= 3,
                    `Expected bpe_ranks in format "! <offset> <b64> <b64> ...", but got too few parts. Prefix: "${bpeRanksStr.slice(0, 120)}..."`
                );
                const [bang, offsetStr, ...tokens] = parts;
                assert(
                    bang === "!",
                    `Expected bpe_ranks to start with "!" but found "${bang}". First few tokens: "${parts.slice(0, 5).join(" ")}"`
                );
                const offset = Number.parseInt(offsetStr, 10);
                assert(
                    Number.isFinite(offset),
                    `Expected numeric offset immediately after "!" in bpe_ranks but found "${offsetStr}".`
                );

                tokens.forEach((tokenB64, i) => {
                    const rank = offset + i;
                    let binaryString;
                    try {
                        binaryString = atob(tokenB64);
                    } catch (e) {
                        throw new Error(
                            `Failed to base64-decode token #${i} ("${tokenB64}") while parsing bpe_ranks: ${e.message}`
                        );
                    }
                    const bytes = new Uint8Array(binaryString.length);
                    for (let j = 0; j < binaryString.length; j++) {
                        bytes[j] = binaryString.charCodeAt(j);
                    }
                    const key = bytes.join(",");
                    if (this.rankMap.has(key)) {
                        throw new Error(
                            `Duplicate byte sequence in bpe_ranks for key "${key}". Expected a one-to-one mapping from byte sequence to rank.`
                        );
                    }
                    this.rankMap.set(key, rank);
                });
            }

            // Returns { count: number, segments: string[], tokenIds: number[], tokenSourceLengths: Uint32Array }
            encodeAndSegment(text) {
                // NOTE: We deliberately ignore JSON `special_tokens` and treat those strings as plain text.
                // This UI tokenizes a single prompt buffer, not a multi-message request/response chain format,
                // so it is more useful to see how the raw characters are tokenized rather than treat specials as control codes.

                const segments = [];
                const tokenIds = [];
                // We track the exact UTF-16 source length contribution of each token. 
                // This is critical for keeping the input textarea (UTF-16) and visualizer (UTF-8 decoded tokens)
                // in perfect scroll sync, especially when emojis or other wide characters get split into multiple byte-tokens.
                const tokenSourceLengths = []; 
                let count = 0;

                // Reset the regex state for this encoding run.
                this.pieceRegex.lastIndex = 0;

                let match;
                while ((match = this.pieceRegex.exec(text)) !== null) {
                    const pieceStr = match[0];
                    const pieceLen = pieceStr.length; // Source length in UTF-16 code units (e.g. Emoji = 2)

                    const pieceBytes = this.textEncoder.encode(pieceStr);
                    const directKey = pieceBytes.join(",");
                    const directRank = this.rankMap.get(directKey);

                    // We need to track how many tokens this one regex match produces,
                    // so we can distribute the source length 'pieceLen' correctly among them.
                    let generatedCount = 0;

                    if (directRank !== undefined) {
                        // Whole piece is a single known token.
                        segments.push(this.textDecoder.decode(pieceBytes));
                        tokenIds.push(directRank);
                        generatedCount = 1;
                        count++;
                    } else {
                        // Need to perform BPE split and map each span to a token id.
                        const splitBytes = bytePairSplit(pieceBytes, this.rankMap);
                        for (const sb of splitBytes) {
                            const key = sb.join(",");
                            const rank = this.rankMap.get(key);
                            if (rank === undefined) {
                                throw new Error(
                                    `BPE split produced a byte sequence with no rank: "${key}". ` +
                                    `This should be impossible if bpe_ranks covers all merges and single-byte tokens.`
                                );
                            }
                            segments.push(this.textDecoder.decode(sb));
                            tokenIds.push(rank);
                            generatedCount++;
                            count++;
                        }
                    }

                    // --- Source Length Distribution Logic ---
                    // Example: An emoji (len 2) might split into 4 byte-tokens.
                    // Visualizer sees 4 tokens (length 4 visual chars, often replacement chars).
                    // Source text only advanced by 2.
                    // We distribute the 2 source units across the 4 tokens (e.g. 1, 1, 0, 0)
                    // ensuring the sum matches the source exactly.
                    let remaining = pieceLen;
                    for (let k = 0; k < generatedCount; k++) {
                        // If it's the last token of this group, it absorbs any remaining length (for safety).
                        // Otherwise, we greedily assign 1 unit of length until we run out.
                        if (k === generatedCount - 1) {
                            tokenSourceLengths.push(remaining);
                        } else {
                            const val = remaining > 0 ? 1 : 0;
                            tokenSourceLengths.push(val);
                            remaining -= val;
                        }
                    }
                }

                // Return buffers to allow zero-copy transfer where possible
                const lengthsBuffer = new Uint32Array(tokenSourceLengths);

                return { 
                    count, 
                    segments, 
                    tokenIds, 
                    tokenSourceLengths: lengthsBuffer 
                };
            }
        }

        let tokenizer = null;

        self.onmessage = function(e) {
            const msg = e.data;
            if (msg.type === 'init') {
                try {
                    tokenizer = new Tiktoken(msg.data);
                    self.postMessage({ type: 'ready' });
                } catch (err) {
                    self.postMessage({ type: 'error', message: err.message });
                }
            } else if (msg.type === 'compute') {
                if (!tokenizer) return;
                try {
                    const result = tokenizer.encodeAndSegment(msg.text);
                    self.postMessage({ 
                        type: 'result', 
                        count: result.count,
                        segments: result.segments,
                        tokenIds: result.tokenIds,
                        tokenSourceLengths: result.tokenSourceLengths, // Pass the corrected lengths back
                        requestId: msg.requestId 
                    }, [result.tokenSourceLengths.buffer]); // Transfer ownership of the large buffer
                } catch (err) {
                    self.postMessage({ type: 'error', message: err.message });
                }
            }
        };
    </script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            services: [
                { 
                    url: "https://chat.example.com/", 
                    modelName: "GPT-OSS 120B Low Thinking",
                    limit: 108000 
                },
                { 
                    url: "https://chat.bad-ai.com/", 
                    modelName: "GPT-OSS 120B No Thinking",
                    limit: 18000 
                }
            ],
            debounceTime: 1500
        };
    
        // --- EMBEDDED MODE CONFIGURATION ---
        // To use embedded mode, replace 'null' below with the Base64 string of the file.
        // The Base64 should represent the binary content of the UTF-8 JSON file.
        // Example: const PRELOADED_BASE64_JSON = "eyJwYXRfc3RyIjogIig/aS..." 
        const PRELOADED_BASE64_JSON = null; 
        
        // STRICT LINE HEIGHT - Must match CSS
        const LINE_HEIGHT_PX = 24;
    
        // --- DOM ELEMENTS ---
        const els = {
            dropZone: document.getElementById('drop-zone'),
            fileInput: document.getElementById('json-upload'),
            loadOverlay: document.getElementById('load-overlay'),
            appContainer: document.getElementById('app-container'),
            errorMsg: document.getElementById('error-msg'),
            totalTokens: document.getElementById('total-tokens'),
            spinner: document.getElementById('main-spinner'),
            providersContainer: document.getElementById('providers-container'),
            input: document.getElementById('text-input'),
            visualizer: document.getElementById('token-visualizer'),
            syncDot: document.getElementById('sync-status'),
            editorContainer: document.getElementById('editor-container'),
            computeBtn: document.getElementById('btn-compute'),
            lineNumberGutter: document.getElementById('line-number-gutter'),
            lineNumberInner: document.getElementById('line-numbers'),
            lineTopSpacer: document.getElementById('line-top-spacer'),
            lineBottomSpacer: document.getElementById('line-bottom-spacer'),
            tooltip: document.getElementById('token-tooltip')
        };
    
        els.tokenTopSpacer = null;
        els.tokenBottomSpacer = null;
        els.tokenInner = null;
    
        // --- STATE ---
        let computationTimeout = null;
        let currentRequestId = 0;
        let pendingSegments = null;
        let pendingTokenIds = null;
        let pendingSourceLengths = null;
        let virtualUpdateTimeout = null;
        const VIRTUAL_DEBOUNCE_MS = 10; // Fast response
    
        // NEW: Active driver tracking to prevent scroll loops
        let activePane = null;
    
        const tokenState = {
            segments: [],
            tokenIds: [],
            lineCharIndices: [], // Maps Line Number -> First Char Index of that line
            tokenStartIndices: null, // Maps Token Index -> Start Char Index
            tokenEndIndices: null,   // Maps Token Index -> End Char Index (exclusive)
            totalLines: 0,
            textSnapshot: "",
            textLength: 0, // Snapshot length for boundary checks
            isSynced: false
        };

        // --- LINE NUMBERS ---
        const lineNumberState = {
            totalLines: 1,
            pendingText: "",
            recountScheduled: false,
            overscan: 5
        };

        function updateLineNumbersFromText(text) {
            if (!els.lineNumberInner) return;
            lineNumberState.pendingText = text || "";
            if (lineNumberState.recountScheduled) return;
            lineNumberState.recountScheduled = true;

            window.requestAnimationFrame(() => {
                lineNumberState.recountScheduled = false;

                const raw = lineNumberState.pendingText || "";
                let lines = 1;
                for (let i = 0; i < raw.length; i++) {
                    if (raw[i] === '\n') lines++;
                }
                lineNumberState.totalLines = Math.max(1, lines);
                // Keep gutter scroll position in sync with the textarea
                syncLineNumberScroll();
            });
        }

        function applyLineNumberViewport() {
            if (!els.lineNumberGutter || !els.lineNumberInner || !els.input || !els.lineTopSpacer || !els.lineBottomSpacer) return;

            const totalLines = Math.max(1, lineNumberState.totalLines || 1);
            const lineHeight = LINE_HEIGHT_PX;
            const scrollTop = els.input.scrollTop || 0;
            const viewportHeight = els.input.clientHeight || els.lineNumberGutter.clientHeight || 0;
            const overscan = lineNumberState.overscan;

            let visibleFirst = Math.floor(scrollTop / lineHeight);
            if (visibleFirst < 0) visibleFirst = 0;
            if (visibleFirst > totalLines - 1) visibleFirst = totalLines - 1;

            let visibleCount = Math.ceil(viewportHeight / lineHeight);
            if (visibleCount < 1) visibleCount = 1;
            if (visibleFirst + visibleCount > totalLines) visibleCount = totalLines - visibleFirst;

            let startLine = visibleFirst - overscan;
            if (startLine < 0) startLine = 0;

            let endLine = visibleFirst + visibleCount + overscan;
            if (endLine > totalLines) endLine = totalLines;
            if (endLine < startLine) endLine = startLine;

            const topHeight = startLine * lineHeight;
            const bottomHeight = (totalLines - endLine) * lineHeight;

            els.lineTopSpacer.style.height = topHeight + 'px';
            els.lineBottomSpacer.style.height = bottomHeight + 'px';

            const needed = endLine - startLine;
            let current = els.lineNumberInner.children.length;

            // Remove extra line elements
            while (current > needed) {
                els.lineNumberInner.removeChild(els.lineNumberInner.lastChild);
                current--;
            }

            // Add missing line elements
            while (current < needed) {
                const div = document.createElement('div');
                div.className = 'line-number';
                els.lineNumberInner.appendChild(div);
                current++;
            }

            // Update line content
            for (let i = 0; i < needed; i++) {
                const lineIndex = startLine + i + 1; // 1-based
                const div = els.lineNumberInner.children[i];
                div.className = 'line-number';
                div.textContent = lineIndex;
            }
        }

        function syncLineNumberScroll() {
            if (!els.lineNumberGutter || !els.input) return;
            els.lineNumberGutter.scrollTop = els.input.scrollTop;
            applyLineNumberViewport();
        }
        
        const blob = new Blob([document.getElementById('worker-script').textContent], { type: "text/javascript" });
        const worker = new Worker(window.URL.createObjectURL(blob));
    
        // --- INITIALIZATION ---
        function initUI() {
            els.providersContainer.innerHTML = '';
            CONFIG.services.forEach((svc, i) => {
                const div = document.createElement('div');
                div.className = 'provider-card';
                div.innerHTML = `
                    <div class="provider-header">
                        <div class="provider-meta">
                            <a href="${svc.url}" class="provider-url" target="_blank">${svc.url}</a>
                            <span class="provider-model" title="${svc.modelName}">${svc.modelName}</span>
                        </div>
                        <div class="provider-stats">
                            <div class="usage-percent" id="p-percent-${i}">0.00%</div>
                            <div class="usage-max">Max: ${(svc.limit / 1000).toFixed(0)}k</div>
                        </div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="p-fill-${i}"></div>
                    </div>
                `;
                els.providersContainer.appendChild(div);
            });
        }
    
        function initVirtualizerDom() {
            if (els.tokenInner) return;
            const top = document.createElement('div');
            top.id = 'token-top-spacer';
            const inner = document.createElement('div');
            inner.id = 'token-visible-inner';
            const bottom = document.createElement('div');
            bottom.id = 'token-bottom-spacer';
    
            els.visualizer.innerHTML = '';
            els.visualizer.appendChild(top);
            els.visualizer.appendChild(inner);
            els.visualizer.appendChild(bottom);
    
            els.tokenTopSpacer = top;
            els.tokenBottomSpacer = bottom;
            els.tokenInner = inner;
        }
    
        // --- DATA HANDLING ---
        function loadTokenizer(json) {
            worker.postMessage({ type: 'init', data: json });
        }
    
        function handleFile(file) {
            if (!file) return;
            els.errorMsg.innerText = "";
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    loadTokenizer(JSON.parse(e.target.result));
                } catch (err) {
                    els.errorMsg.innerText = "Error: " + err.message;
                }
            };
            reader.readAsText(file);
        }
    
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
            els.dropZone.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); });
        });
        els.dropZone.addEventListener('drop', (e) => handleFile(e.dataTransfer.files[0]));
        els.dropZone.addEventListener('click', () => els.fileInput.click());
        els.fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));
    
        // --- STATE BUILDING ---
        function rebuildTokenState(text, segments, tokenIds, tokenSourceLengths) {
            tokenState.segments = Array.isArray(segments) ? segments.slice() : [];
            tokenState.tokenIds = Array.isArray(tokenIds) ? tokenIds.slice() : [];
            tokenState.textSnapshot = text;
            tokenState.textLength = text.length;
            
            // Normalize length mismatch defensively (shouldn't happen with the fix, but fail-soft if it does)
            if (tokenState.tokenIds.length && tokenState.tokenIds.length !== tokenState.segments.length) {
                const minLen = Math.min(tokenState.segments.length, tokenState.tokenIds.length);
                tokenState.segments.length = minLen;
                tokenState.tokenIds.length = minLen;
            }
            
            // 1. Map Line -> Start Char
            tokenState.lineCharIndices = [0];
            for (let i = 0; i < text.length; i++) {
                if (text[i] === '\n') {
                    tokenState.lineCharIndices.push(i + 1);
                }
            }
            tokenState.totalLines = tokenState.lineCharIndices.length;
    
            // 2. Map Token -> Start/End Char (exclusive)
            const len = tokenState.segments.length;
            tokenState.tokenStartIndices = new Uint32Array(len);
            tokenState.tokenEndIndices = new Uint32Array(len);
            let runningLength = 0;
            
            // Safety check: Ensure we actually received the source length data from the worker
            const hasSourceData = tokenSourceLengths && tokenSourceLengths.length === len;

            for (let i = 0; i < len; i++) {
                tokenState.tokenStartIndices[i] = runningLength;
                
                // CRITICAL: We use the source length provided by the worker (which distributes UTF-16 units correctly)
                // instead of the decoded segment length (which might be inflated due to replacement chars).
                // If data is missing (legacy path), we fall back to segment.length, accepting potential drift.
                const segLen = hasSourceData ? tokenSourceLengths[i] : tokenState.segments[i].length;
                
                runningLength += segLen;
                tokenState.tokenEndIndices[i] = runningLength;
            }

            // Update line numbers whenever we rebuild token state
            updateLineNumbersFromText(text);
        }
    
        // --- HELPER: CHAR -> LINE MAPPING ---
        // This allows us to find exactly which line a token starts on, even if it's mid-file
        function getLineForCharIndex(charIdx) {
            let low = 0, high = tokenState.lineCharIndices.length - 1;
            while (low <= high) {
                let mid = (low + high) >>> 1;
                if (tokenState.lineCharIndices[mid] === charIdx) return mid;
                if (tokenState.lineCharIndices[mid] < charIdx) low = mid + 1;
                else high = mid - 1;
            }
            return Math.max(0, high);
        }
    
        // Returns the index of the token whose span covers charIndex,
        // clamped to [0, lastToken]. If charIndex is before the first
        // token, returns 0. If it is at or beyond the end of the text,
        // returns the last token index.
        function findTokenIndexForChar(charIndex) {
            const ends = tokenState.tokenEndIndices;
            const n = ends ? ends.length : 0;
            if (n === 0) return 0;

            // Clamp to valid character range
            if (charIndex <= 0) return 0;

            const lastEnd = ends[n - 1];

            // If we are at or past the end of the text, treat this as the last token
            if (charIndex >= lastEnd) return n - 1;

            let left = 0;
            let right = n - 1;
            while (left <= right) {
                const mid = (left + right) >>> 1;
                const start = mid === 0 ? 0 : ends[mid - 1];
                const end = ends[mid];

                if (charIndex < start) {
                    right = mid - 1;
                } else if (charIndex >= end) {
                    left = mid + 1;
                } else {
                    return mid;
                }
            }
            // Fallback: best-effort clamp
            return Math.max(0, Math.min(n - 1, left));
        }

        // Returns the index of the first token whose start position is
        // greater than or equal to charIndex. If charIndex is after the
        // last token, returns tokenState.segments.length (exclusive upper bound).
        function findFirstTokenIndexAtOrAfterChar(charIndex) {
            const starts = tokenState.tokenStartIndices;
            const ends = tokenState.tokenEndIndices;
            const n = starts ? starts.length : 0;
            if (n === 0) return 0;

            const lastEnd = ends[n - 1];

            if (charIndex <= 0) return 0;
            if (charIndex >= lastEnd) return n;

            let left = 0;
            let right = n - 1;
            let result = n;

            while (left <= right) {
                const mid = (left + right) >>> 1;
                if (starts[mid] >= charIndex) {
                    result = mid;
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            return result;
        }
    
        // --- VIRTUALIZATION LOGIC ---
        function scheduleVirtualUpdate() {
            if (!tokenState.isSynced || !els.tokenInner) return;
            if (virtualUpdateTimeout) clearTimeout(virtualUpdateTimeout);
            virtualUpdateTimeout = setTimeout(applyVirtualViewport, VIRTUAL_DEBOUNCE_MS);
        }
    
        function applyVirtualViewport() {
            if (!tokenState.segments.length) {
                // Reset spacers and tokens when empty
                if (els.tokenTopSpacer) els.tokenTopSpacer.style.height = '0px';
                if (els.tokenBottomSpacer) els.tokenBottomSpacer.style.height = '0px';
                renderVisualizer([], 0);
                return;
            }

            // 1. Where are we in the viewport?
            const scrollTop = els.input.scrollTop;
            const viewportHeight = els.input.clientHeight;
            
            // 2. Determine target lines
            // Use Math.floor/ceil to map pixels to logical lines
            let startLine = Math.floor(scrollTop / LINE_HEIGHT_PX);
            let endLine = Math.ceil((scrollTop + viewportHeight) / LINE_HEIGHT_PX);

            // 3. Overscan (Render extra lines to prevent gray flicker)
            const OVERSCAN = 5; 
            let safeStartLine = Math.max(0, startLine - OVERSCAN);
            let safeEndLine = Math.min(tokenState.totalLines, endLine + OVERSCAN);

            // Clamp start so it's always a valid line index
            if (tokenState.totalLines > 0) {
                safeStartLine = Math.min(safeStartLine, tokenState.totalLines - 1);
            }

            // Ensure we always have at least one line in the window
            if (safeEndLine <= safeStartLine) {
                safeEndLine = Math.min(tokenState.totalLines, safeStartLine + 1);
            }

            // 4. Find the Token that starts at 'safeStartLine'
            const startCharIndex = tokenState.lineCharIndices[safeStartLine] || 0;
            let startTokenIndex = findTokenIndexForChar(startCharIndex);

            /* --- FIX: Stabilize the Spacer Calculation ---
               We need to know where this token *actually* starts to set the spacer.
               Using the token's true start char keeps spacer height consistent and
               avoids off-by-one line drift. 
               
               Since we now have the true source indices (thanks to tokenSourceLengths), 
               getLineForCharIndex will return the exact physical line in the textarea.
            */
            let tokenStartChar = 0;
            if (startTokenIndex > 0) {
                 tokenStartChar = tokenState.tokenEndIndices[startTokenIndex - 1];
            }

            const actualTokenStartLine = getLineForCharIndex(tokenStartChar);

            // 5. Find End Token (exclusive upper bound)
            let endTokenIndex;
            if (safeEndLine >= tokenState.totalLines) {
                 endTokenIndex = tokenState.segments.length;
            } else {
                 const endCharIndex = tokenState.lineCharIndices[safeEndLine];
                 // Use a boundary-aware search: first token whose start >= endCharIndex.
                 // This keeps EOF behavior stable even when endCharIndex === text.length.
                 endTokenIndex = findFirstTokenIndexAtOrAfterChar(endCharIndex);
            }

            // Safety clamps
            if (startTokenIndex < 0) startTokenIndex = 0;
            if (endTokenIndex < startTokenIndex) endTokenIndex = startTokenIndex;
            if (endTokenIndex > tokenState.segments.length) endTokenIndex = tokenState.segments.length;

            // 6. Calculate Spacers
            // The top spacer must represent the height of the lines strictly BEFORE the first rendered token.
            const topSpacerHeight = actualTokenStartLine * LINE_HEIGHT_PX;
            
            // The bottom spacer fills the rest of the document height
            // Calculating based on remaining lines is safer than pixel subtraction to avoid negative gaps
            const bottomSpacerHeight = Math.max(0, (tokenState.totalLines - safeEndLine) * LINE_HEIGHT_PX);

            // Apply
            if (els.tokenTopSpacer) els.tokenTopSpacer.style.height = topSpacerHeight + 'px';
            if (els.tokenBottomSpacer) els.tokenBottomSpacer.style.height = bottomSpacerHeight + 'px';

            // 7. Render
            const visibleSegments = tokenState.segments.slice(startTokenIndex, endTokenIndex);
            renderVisualizer(visibleSegments, startTokenIndex);

            // 8. Sync Scroll Position (Driver Logic)
            if (activePane === 'left' && Math.abs(els.visualizer.scrollTop - scrollTop) > 1) {
                els.visualizer.scrollTop = scrollTop;
            }
        }
    
        function renderVisualizer(segments, offsetIndex = 0) {
            const fragment = document.createDocumentFragment();
            segments.forEach((seg, index) => {
                const span = document.createElement('span');
                span.textContent = seg;
                const globalIndex = offsetIndex + index;
                span.className = `t-token c${globalIndex % 6}`;
                
                const tokenIds = tokenState.tokenIds;
                const tokenId = (tokenIds && tokenIds.length > globalIndex)
                    ? tokenIds[globalIndex]
                    : undefined;

                span.dataset.tokenIndex = String(globalIndex);
                if (tokenId !== undefined) {
                    span.dataset.tokenId = String(tokenId);
                }
                
                fragment.appendChild(span);
            });
            
            const target = els.tokenInner;
            target.innerHTML = '';
            target.appendChild(fragment);
            pendingSegments = null;
        }
    
        // --- TOKEN TOOLTIP HELPERS (custom, so it works reliably in desktop browsers) ---
        function findTokenSpanFromEvent(e) {
            let node = e.target;
            while (node && node !== els.visualizer) {
                if (node.classList && node.classList.contains('t-token')) return node;
                node = node.parentNode;
            }
            return null;
        }

        function hideTooltip() {
            if (!els.tooltip) return;
            els.tooltip.classList.add('hidden');
        }

        function handleVisualizerMouseMove(e) {
            if (!els.tooltip) return;
            const span = findTokenSpanFromEvent(e);
            if (!span) {
                hideTooltip();
                return;
            }
            const tokenIndex = span.dataset.tokenIndex ?? "?";
            const tokenId = span.dataset.tokenId;
            const rawText = span.textContent || "";
            
            // Old: const displayText = rawText.replace(/\s/g, " ");
            // New: Use JSON stringify to escape characters, then strip the surrounding quotes
            const displayText = JSON.stringify(rawText).slice(1, -1);

            const truncated = displayText.length > 40 ? displayText.slice(0, 37) + "â€¦" : displayText;

            const label = tokenId !== undefined
                ? `#${tokenIndex} Â· id=${tokenId} Â· "${truncated}"`
                : `#${tokenIndex} Â· "${truncated}"`;

            els.tooltip.textContent = label;
            els.tooltip.classList.remove('hidden');

            const offsetX = 12;
            const offsetY = 18;
            let x = e.clientX + offsetX;
            let y = e.clientY + offsetY;

            const rect = els.tooltip.getBoundingClientRect();
            const vw = window.innerWidth;
            const vh = window.innerHeight;

            if (x + rect.width + 8 > vw) x = vw - rect.width - 8;
            if (y + rect.height + 8 > vh) y = vh - rect.height - 8;

            els.tooltip.style.left = x + 'px';
            els.tooltip.style.top = y + 'px';
        }
    
        // --- EVENTS & HANDLERS ---
    
        function triggerComputation() {
            const text = els.input.value;
            currentRequestId++;
            if (text.length === 0) {
                updateTokenStats(0);
                rebuildTokenState("", [], [], []);
                if (els.tokenInner) {
                    els.tokenInner.innerHTML = '';
                }
                if (els.tokenTopSpacer) els.tokenTopSpacer.style.height = '0px';
                if (els.tokenBottomSpacer) els.tokenBottomSpacer.style.height = '0px';
                setSyncState('synced');
                return;
            }
            setSyncState('working');
            worker.postMessage({ type: 'compute', text: text, requestId: currentRequestId });
        }
    
        els.input.addEventListener('input', () => {
            els.spinner.classList.add('active');
            els.visualizer.classList.add('stale');
            els.computeBtn.disabled = true; 
            els.computeBtn.innerText = "Computing...";
            setSyncState('working');
            if (computationTimeout) clearTimeout(computationTimeout);
            computationTimeout = setTimeout(triggerComputation, CONFIG.debounceTime);

            // Update line numbers immediately as the user types
            updateLineNumbersFromText(els.input.value || "");
        });
    
        els.computeBtn.addEventListener('click', () => {
            if (pendingSegments && pendingTokenIds) {
                // Pass the pending source lengths as well to maintain sync logic
                rebuildTokenState(els.input.value || "", pendingSegments, pendingTokenIds, pendingSourceLengths);
                setSyncState('synced');
            }
        });
    
        function setSyncState(state) {
            if(state === 'working') {
                els.syncDot.className = 'sync-dot working';
                tokenState.isSynced = false;
            } else if (state === 'ready') {
                els.syncDot.className = 'sync-dot working';
                els.spinner.classList.remove('active');
                els.computeBtn.disabled = false;
                els.computeBtn.innerText = "Update View";
            } else {
                els.syncDot.className = 'sync-dot synced';
                els.spinner.classList.remove('active');
                els.visualizer.classList.remove('stale');
                els.computeBtn.disabled = true;
                els.computeBtn.innerText = "Up to Date";
                tokenState.isSynced = true;
                scheduleVirtualUpdate();
            }
        }
    
        function updateTokenStats(count) {
            els.totalTokens.innerText = count.toLocaleString();
            CONFIG.services.forEach((svc, i) => {
                const pctEl = document.getElementById(`p-percent-${i}`);
                const fillEl = document.getElementById(`p-fill-${i}`);
                const percent = (count / svc.limit) * 100;
                pctEl.innerText = Math.min(percent, 999).toFixed(2) + "%";
                fillEl.style.width = Math.min(percent, 100) + "%";
                if (count > svc.limit) {
                    pctEl.classList.add('over-limit');
                    fillEl.classList.add('danger');
                } else {
                    pctEl.classList.remove('over-limit');
                    fillEl.classList.remove('danger');
                }
            });
        }
    
        // Worker Message Handler
        worker.onmessage = (e) => {
            const msg = e.data;
            if (msg.type === 'ready') {
                els.loadOverlay.style.opacity = '0';
                setTimeout(() => {
                    els.loadOverlay.style.display = 'none';
                    els.appContainer.style.display = 'flex';
                    initUI();
                    initVirtualizerDom();
                    scheduleVirtualUpdate();
                    updateLineNumbersFromText(els.input.value || "");
                }, 300);
            } else if (msg.type === 'result') {
                if (msg.requestId === currentRequestId) {
                    updateTokenStats(msg.count);
                    pendingSegments = msg.segments;
                    pendingTokenIds = msg.tokenIds || [];
                    pendingSourceLengths = msg.tokenSourceLengths || []; // Receive Source Length Buffer
                    
                    rebuildTokenState(
                        els.input.value || "", 
                        msg.segments, 
                        msg.tokenIds || [], 
                        msg.tokenSourceLengths
                    );
                    setSyncState('synced');
                }
            } else if (msg.type === 'error') {
                alert(msg.message);
                setSyncState('synced');
            }
        };
    
        // --- STARTUP & SCROLL SYNC ---
        window.addEventListener('DOMContentLoaded', () => {
            if(PRELOADED_BASE64_JSON) {
                try {
                    const binaryString = atob(PRELOADED_BASE64_JSON);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
                    const jsonString = new TextDecoder('utf-8').decode(bytes);
                    loadTokenizer(JSON.parse(jsonString));
                } catch (e) {
                    els.errorMsg.innerText = "Embedded data corruption: " + e.message;
                }
            }
    
            initUI();
            initVirtualizerDom();
            updateLineNumbersFromText(els.input.value || "");
            window.addEventListener('resize', () => {
                scheduleVirtualUpdate();
                applyLineNumberViewport();
            });
    
            // --- MOUSE TRACKING (Driver Pattern) ---
            // Determines which pane controls the synchronization
            els.input.addEventListener('mouseenter', () => { activePane = 'left'; });
            els.visualizer.addEventListener('mouseenter', () => { activePane = 'right'; });
            document.body.addEventListener('mouseleave', () => { activePane = null; });
    
            // Left Pane Scroll (Driver)
            els.input.addEventListener('scroll', () => {
                scheduleVirtualUpdate(); // Always virtualize
                if (activePane === 'left') {
                    els.visualizer.scrollTop = els.input.scrollTop;
                }
                syncLineNumberScroll();
            });
    
            // Right Pane Scroll (Driver)
            els.visualizer.addEventListener('scroll', () => {
                if (activePane === 'right') {
                    els.input.scrollTop = els.visualizer.scrollTop;
                    scheduleVirtualUpdate(); // Update visualization as we scroll right pane too
                    syncLineNumberScroll();
                }
            });

            // Attach tooltip handlers so hovering over tokens in any desktop browser shows correct id/index.
            els.visualizer.addEventListener('mousemove', handleVisualizerMouseMove);
            els.visualizer.addEventListener('mouseleave', hideTooltip);
        });
    </script>
</body>
</html>
